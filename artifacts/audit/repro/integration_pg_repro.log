usage: run.py [-h] [--season SEASON] [--round ROUND_NUM] [--rounds ROUNDS]
              [--dry-run] [--seasons SEASONS] [--bankroll BANKROLL]
              [--out OUT] [--source-name SOURCE_NAME]
              [--source-ref SOURCE_REF] [--canary-path CANARY_PATH]
              [--authoritative-payload-path AUTHORITATIVE_PAYLOAD_PATH]
              [--calibration-season CALIBRATION_SEASON]
              [--backtest-season BACKTEST_SEASON]
              {init,full,daily,scrapers,deploy,train,report,fit-calibration,backfill,label-outcomes,backtest,seed,data-quality,rectify-clean,schema-parity-smoke,ops-parity-smoke,rebuild-clean-baseline,scraper-status,doctor}

positional arguments:
  {init,full,daily,scrapers,deploy,train,report,fit-calibration,backfill,label-outcomes,backtest,seed,data-quality,rectify-clean,schema-parity-smoke,ops-parity-smoke,rebuild-clean-baseline,scraper-status,doctor}

options:
  -h, --help            show this help message and exit
  --season SEASON
  --round ROUND_NUM
  --rounds ROUNDS       Comma-separated round numbers for backfill/backtest
                        (default: all)
  --dry-run             Persist artifacts but mark slips as dry_run; skip
                        notify by default
  --seasons SEASONS
  --bankroll BANKROLL   Initial bankroll for backtesting
  --out OUT
  --source-name SOURCE_NAME
  --source-ref SOURCE_REF
  --canary-path CANARY_PATH
  --authoritative-payload-path AUTHORITATIVE_PAYLOAD_PATH
  --calibration-season CALIBRATION_SEASON
  --backtest-season BACKTEST_SEASON
OK slips matches_raw
.................................F....................                   [100%]
=================================== FAILURES ===================================
___________________________ test_pg_lifecycle_smoke ____________________________

self = <sqlalchemy.engine.base.Connection object at 0x7fa5dd51c140>
engine = Engine(postgresql+psycopg://postgres:***@localhost:5432/edge_engine)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'host=localhost dbname=edge_engine user=postgres password=postgres port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = 5
context = <psycopg.adapt.AdaptersMap object at 0x7fa5dcefdbb0>
row_factory = None, cursor_factory = None
kwargs = {'dbname': 'edge_engine', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
params = {'dbname': 'edge_engine', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?

/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/psycopg/connection.py:119: OperationalError

The above exception was the direct cause of the following exception:

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fa5dd51c170>

    def test_pg_lifecycle_smoke(monkeypatch):
        from engine.schema_router import ops_table, truth_table  # noqa: F401
    
        db_url = os.getenv("DATABASE_URL", "")
        integration_required = os.getenv("INTEGRATION_TEST", "0") == "1"
    
        if "postgresql" not in db_url:
            if integration_required:
                pytest.fail(
                    "INTEGRATION_TEST=1 requires DATABASE_URL to point to PostgreSQL"
                )
            pytest.skip("DATABASE_URL is not configured for PostgreSQL")
    
        from engine.db import get_engine
        from engine.run import (
            cmd_backfill,
            cmd_backtest,
            cmd_deploy,
            cmd_fit_calibration,
            cmd_init,
            cmd_label_outcomes,
            cmd_seed,
            cmd_train,
        )
    
        monkeypatch.setenv("QUALITY_GATE_SEASONS", "2022,2023,2024,2025")
        engine = get_engine()
    
>       cmd_init(engine)

tests/test_integration_pg.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
engine/run.py:151: in cmd_init
    apply_schema(engine)
engine/run.py:31: in apply_schema
    with engine.begin() as conn:
/root/.pyenv/versions/3.12.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'host=localhost dbname=edge_engine user=postgres password=postgres port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = 5
context = <psycopg.adapt.AdaptersMap object at 0x7fa5dcefdbb0>
row_factory = None, cursor_factory = None
kwargs = {'dbname': 'edge_engine', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
params = {'dbname': 'edge_engine', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           sqlalchemy.exc.OperationalError: (psycopg.OperationalError) connection failed: connection to server at "127.0.0.1", port 5432 failed: Connection refused
E           	Is the server running on that host and accepting TCP/IP connections?
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

/root/.pyenv/versions/3.12.12/lib/python3.12/site-packages/psycopg/connection.py:119: OperationalError
=========================== short test summary info ============================
FAILED tests/test_integration_pg.py::test_pg_lifecycle_smoke - sqlalchemy.exc...
1 failed, 53 passed in 3.03s
